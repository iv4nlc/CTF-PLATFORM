### Paso a paso para extraer la flag

1. **Entender el _Calling Convention_ de 64 bits**  
   En sistemas de 64 bits los primeros seis parámetros de una función se pasan a través de los registros en lugar de la pila. En este caso, `printf` utiliza los registros `rdi`, `rsi`, `rdx`, `rcx`, `r8`, y `r9` para sus primeros argumentos. Por lo tanto, los primeros valores que se muestran al imprimir con `%x` o `%lX` provienen de estos registros, no de la pila.

2. **Uso de un Payload extendido para acceder a la pila**  
   Para acceder a la flag, que se encuentra en la pila, necesitas "saltar" los registros iniciales. Puedes hacer esto usando suficientes especificadores de formato `%lX` para avanzar hasta las posiciones que correspondan a la pila. Esto lo haces con un comando como:
   ```bash
   python3 -c 'print("%lX "*16)' | ./format_string
   ```
   Este comando imprime los valores de los registros y, eventualmente, los valores de la pila.

3. **Interpretar la Salida**  
   La salida del programa puede verse algo como esto:
   ```
   Hello 20 0 0 7 55701949B2A0 20586C2520586C25 ... 7340707B47414C46 6134686472347773 333231676E316B63 FLAG{p@ssw4rdh4ack1ng1230#safe}
   ```
   - Los primeros valores (`20 0 0 7 55701949B2A0 ...`) corresponden a los registros, debido al _calling convention_ de 64 bits.
   - Luego, 20586C2520586C25 se corresponde con `%lx`.
   - En la pila encuentras bloques que contienen la flag en forma hexadecimal. La flag se divide en partes, por ejemplo:
     - `7340707B47414C46` -> `FLAG{p@` (leído por pares de derecha a izquierda debido al little endian)
     - `6134686472347773` -> `ssw4rdh`
     - `333231676E316B63` -> `ack1ng12`

Por supuesto, también podría usarse ghidra o gdb para mirar directamente la dirección donde se encuentra almacenada la flag (por ejemplo, con %100$lx podríamos leer directamente la posición número 100). Como es de los primeros ejercicios, nos conformamos con esta rápida solución.